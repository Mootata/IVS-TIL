# C언어

## 1. 함수 매개변수
C언어에서 매개변수가 없을 경우 foo(void){}와 같이 명시적으로 void를 적어야 함
Goo(){} 이는 매개변수를 검증하지 않겠다는 의미

## 2. 변수
실행시간에 정해지는 값, 메모리에 할당되어 관리되는 값

### Built-in type (내장 타입)
1. char는 문자 타입, signed unsigned char는 1바이트 정수 타입
2. char는 1바이트
3. 정수 타입의 크기는 플랫폼, 컴파일러마다 달라질 수 있음.
4. 정수 타입을 바로 사용하는 것은 위험, typedef를 통해 정의된 타입을 사용하는 것이 중요
ex) stdint.h 활용 int8_t, uint32_t

### 문자 타입
- char

### 정수 타입
- char (char의 경우 명시적으로 표시해 줘야 함)
    - signed char (부호 O)
    - unsigned char (부호 X)
- short / unsigned short
- int / unsigned int
- long / unsigned long
- long long / unsigned long long

### 실수 타입
마찬가지로 플랫폼과 컴파일러에 따라 크기가 달라질 수 있음
- float
- double
- long double

따라서 typedef float float32_t 와 같이 사용

실수타입의 경우 정밀도에 따라 오차가 발생함 따라서 실수 타입의 동등성 비교를 수행할 때 주의가 필요  
```C
0.5 == 0.1 * 5
// 위의 경우 타입에 따라 오차 발생 가능  
if(fabs(0.5 -(0.1 * 5)) < 0.000000001){  
    printf("같다.");
}{  
    printf("다르다.");
}
```
  
이처럼 오차범위 내에 들어오는지를 확인하는게 좋음

### sizeof
각 타입에 대응하는 형식 지정자를 사용하는 것이 필요
```C
sizeof의 size_t = %zu
printf("%zu", sizeof(int))
sizeof(식별자) or sizeof 식별자 // 둘 다 가능
sizeof(타입) // 괄호 무조건 필요
```

### 주석처리
1. //
2. /**/ (중첩이 안됨)
3. if 0, endif

### devdocs.io

### boolean
보통 아래와 같이 사용
```C
typedef int BOOL;
#define TRUE 1
#define FALSE 0;

int main(void){
    BOOL b1 = TRUE;
    BOOL b2 = FALSE;

    return 0;
}
```

### 64비트 기준
정수의 크기(타입)에 따라 표현 범위가 달라짐
- signed char(1바이트): -128 ~ 127 / 0 ~ 255
- short(2바이트): -32768 ~ 32767 / 0 ~ 65535
- int(4바이트): -21억 ~ 21억 / 0 ~ 42억
- long long(8바이트)

위의 표현 범위를 벗어난 값을 넣을 경우 overflow 발생, 하지만 경고를 표시할 뿐 실행은 가능, 따라서 개발자가 알아서 주의해야함

아래의 경우 경고 발생
```C
short s = 40000; // short의 범위 32767을 벗어남
printf("%d\n", s);
```

아래의 경우는 경고도 발생하지 않음
```C
int i = 40000
short s = i; // short의 범위 32767을 벗어남
printf("%d\n", s);
```


### 계산

#### 음수
2의 보수법
- 부호가 있는 정수 타입은 최상위 비트를 부호 비트로 이용 1은 음수, 0은 양수  

```C
signed char a = 128;
// 1000 0000
// => signed 타입이 더 큰 표현범위의 타입으로 변환될 때, 부호비트로 확장한다.
// 따라서 a를 출력하면 -128이 출력됨
```

### 변수의 종류
1. 전역 변수
- 프로그램이 시작될 때 초기화되고, 종료될 때까지 유지 
- Data 영역에 저장
- 초기화하지 않으면 자동으로 0으로 초기화 됨
2. 지역 변수
- 함수 안에서 초기화되고, 함수가 종료될 때 파괴된다.
- Stack 영역에 저장
- 초기화하지 않으면 쓰레기 값으로 초기화 됨
- 전역 변수와 달리 자동으로 0으로 초기화 되지 않는 이유는 전역 변수는 한번만 초기화되어 성능상의 문제가 없지만, 지역 변수는 다르기 때문
- 메모리 할당과 해지의 비용이 없음
3. 정적 지역 변수
- static 을 붙이면 됨.
- 지역 변수에 static을 붙이면 스택이 아닌 데이터 영역으로 변경하는 키워드
- 함수가 최초에 실행되는 시점에 초기화되고, 프로그램이 종료될 때까지 유지
- Data 영역에 저장 
4. 동적 메모리 할당
- 실행시간(Runtime)에 개발자가 원하는 타이밍에 생성하고 파괴할 수 있는 변수
- 메모리 누수의 위험성
- 메모리 할당과 해지의 비용이 큼 (동적 메모리 할당의 경우 요청이 발생하면 청크를 찾고, 해당 크기의 청크가 없다면 더 큰 청크를 쪼갬, 반납시에도 동일하게 인접한 청크가 있을 경우 다시 합쳐서 관리하는 등의 과정으로 인해 비용 발생)

이 종류에 따라 변수의 수명이 달라짐

### 다른 파일의 변수
다른 파일의 변수를 사용하기 위해서는 선언을 통해 컴파일러에게 알려주는 것이 필요함  

```C
// B.c
int n = 100;

void foo(void){
    printf("hi");
}

static int password = 1234; // 다른 파일에서 접근할 수 없는 전역 변수 (Internal Linkage)

```
```C
// A.c

int n; // 이 경우 작동은 잘 하지만 개발자 입장에서 초기화를 하지 않은 변수인지, 선언인지 헷갈릴 수 있음
extern int n; // 따라서 extern을 명시해주는 것이 좋음
printf("%d\n", n) // 100 출력

void foo(void) // 등등
foo() // hi 출력


```
### static
- 기억 부류 지정자
- 통용 범위 지정자
    - 전역 변수 / 함수를 내부 연결(Internal Linkage)로 변경할 수 있음

### 초기화와 대입
초기화
- 변수를 생성하면서 (메모리를 할당하면서), 값을 지정
- const와 같은 경우 컴파일 에러는 발생하지 않지만, 무조건 초기화를 해야함

대입
- 이미 할당된 메모리(만들어진 변수의) 값을 지정

### Type
C언어에서 변수의 Type은 이름을 제외한 부분을 의미함.
```C
int n = 3; // int 타입
int x[3]; // int[3] 타입
```

### 변수와 메모리
- 변수는 메모리에 할당
- 변수가 할당된 메모리에 식별자를 통해서 접근 가능 
- & 연산자를 통해 할당된 메모리의 주소값(위치)를 알 수 있음
- 주소를 출력할 때는 %p 서식을 사용

### typedef
- 기존 타입에 별칭을 부여
- 가독성을 높이기 위함
```C
typedef unsigned char age_t;

unsigned char age;
age_t age;
// 위의 둘은 동일한 의미

typedef int x_t[3];
// int[3]

x_t x;
x[0] = 10;
x[1] = 20;
x[2] = 30;

for (i = 0; i < 3; i++){
    printf("%d\n", x[i]);
}
```

## 연산자

#### 연산자 우선순위는 연산을 먼저 수행하는 개념이 아니라 결합을 결정하는 것.)

### &&, ||
&&가 || 보다 우선순위가 높다.  

```C
c = a++ && ++b
위의 경우 a는 결국 1이 더해지겠지만, &&의 특징으로 인하여 a가 0이었기에 뒤의 식을 아예 수행하지 않게되어 b는 여전히 0이 된다.
a, b, c = 1, 0, 0

c = ++a || b ++;
a, b, c = 1, 0, 1

d = ++a || ++b && c++;
결국 위의 식은 아래와 같음
d = ++a || (++b && c++);
or 연산이기 떄문에, 앞의 a가 1이기에 뒤의 식은 수행하지 않음. 따라서 답은 아래와 같음
a, b, c, d = 1, 0, 0, 1
```
- 대입 연산자 (=)
```C
a = b = c = 100; 
a = b = 100;
a = 100;
100;
대부분의 연산과 달리 연산의 방향이 <- 임
```

#### 이러한 특징으로 인해 &&, ||를 함께 사용할 경우 반드시 ()를 잘 사용해줘야 함.

### %, /
```C
int is_even(int n){
    return n & 1 == 0;
    // return n & (1 == 0);
    // 의도와는 다르게 우선순위에 따라 괄호가 다르게 묶임
    // 따라서 괄호를 잘 사용해 줘야 함
    // return (n & 1) == 0;
}
```
### <<, >>
- 산술 쉬프트: 피연산자의 타입이 signed일 때  
쉬프트의 결과로 채워지는 비트가 부호비트로 채워짐 (양수 = 0, 음수 = 1)
- 논리 쉬프트: 피연산자의 타입이 unsigned일 때

```C
int n = 32;
// 0001 0000
printf("%d\n", n >> 1);
// 00001 0000

int n = -32;
// 1111 1111 1110 0000: -32
// 1111 1111 1111 0000: -16
printf("%d\n", n >> 1);
// 00001 0000
```

## 입출력
### 

## 제어문
### 조건문 (Conditional Statement)
조건의 범위를 좁은 범위에서 넓히는 형태로 만드는게 좋다.
- if
- if-else
- if-else if-else (else는 처리할 내용이 없어도 필수)
- switch (break문 필요, 위와 마찬가지로 default는 필수(맨위나 맨밑에만 써야 함))  
의도적으로 특정 값의 입력에 대해 default와 동일한 행위를 할 경우 주석을 통해 fallthrough 라고 적어주어야 함.
```C
case 'A':
    printf("A");
case 'B':
    // fallthrough
default:
    printf("zz");
```
### 반복문 (Iterative Statement)
- for문 (몇 번 수행할지 예상할 수 있을 떄)
- while문 (몇 번 수행될지 예상할 수 없을 때)

PS. goto는 일반적으로 사용하면 안됨. (스파게티 코드)
하지만 아래의 경우 사용하기도 함  
1. 중첩된 반복문을 탈출할 때
2. 오류 처리

### 미정의 동작
1. 초기화 되지 않은 메모리 값을 읽거나 사용하는 행위
2. 하나의 표현식 안에서 값이 두 번 이상 변경되는 것, 두개 이상의 부수효과(side effect)가 발생하는 것
```C 
int a = 0;
int result = ++a + ++a;
```

